import logging
from typing import List

from langchain_openai import ChatOpenAI
from langchain_core.messages import SystemMessage, BaseMessage

from prompts.prompts import MILESTONE_FORMULATOR_CONTEXT, MILESTONE_FORMULATOR_PROMPT
from agents.agent_utils import (
    extract_json,
    fill_prompt_template,
    PlanState,
    AgentMessage,
)
import agents.agent_utils as agent_utils
from persistence.dynamodb_database import DynamoDBHandler
from schemas.core_v2 import (
    Milestone,
    Tracker,
    TargetMetric,
    AchievementMetric,
    CumulativeMetric,
)
from llms.openai_api import low_reasoning_gpt5mini

# Setup logging
logger = logging.getLogger(__name__)


def get_metric(metric_data: dict):
    m_type = metric_data.get("type", "").lower()
    if m_type == "target":
        return TargetMetric(**metric_data)
    elif m_type == "achievement":
        return AchievementMetric(**metric_data)
    elif m_type == "cumulative":
        return CumulativeMetric(**metric_data)

    logger.error(f"Unknown metric type encountered: {m_type}")
    raise ValueError(f"Unknown metric type: {m_type}")


def commit_milestones(milestones: List, state: PlanState):
    logger.info(f"Committing {len(milestones)} milestones for user {state['user_id']}")

    milestones_objs = []
    trackers_objs = []
    milestone_id_maps = {}  # Map from LLM temp IDs to Autogenerated IDs
    # breakpoint()
    # First pass: Create objects and trackers
    for m in milestones:
        milestone_obj = Milestone(
            user_id=state["user_id"],
            goal_id=state["structured_data"]["goal"].goal_id,
            statement=m["statement"],
        )

        for t in m.get("trackers", []):
            trackers_objs.append(
                Tracker(
                    user_id=state["user_id"],
                    milestone_id=milestone_obj.milestone_id,
                    **t,
                )
            )

        milestones_objs.append(milestone_obj)
        milestone_id_maps[m["id"]] = milestone_obj.milestone_id

    # Second pass: Link dependencies using the ID map
    for m_llm, m_obj in zip(milestones, milestones_objs):
        m_obj.depends_on = [
            milestone_id_maps[dep_id]
            for dep_id in m_llm.get("depends_on", [])
            if dep_id in milestone_id_maps
        ]

    # breakpoint()

    repo = DynamoDBHandler(region_name="us-east-1")

    for m in milestones_objs:
        repo.create_milestone(m)
    for t in trackers_objs:
        repo.create_tracker(t)

    logger.info(
        f"Successfully persisted {len(milestones_objs)} milestones and {len(trackers_objs)} trackers."
    )
    return milestones_objs, trackers_objs


def get_next_agent_using_intent(intent: str):
    next_agent = (
        agent_utils.ORCHESTRATOR
        if intent == "ORCHESTRATOR"
        else agent_utils.MILESTONE_FORMULATOR
    )
    logger.debug(f"Routing logic determined agent: {next_agent}")
    return next_agent


def get_full_context(state: PlanState):
    system_message = SystemMessage(
        content=fill_prompt_template(MILESTONE_FORMULATOR_PROMPT, {})
    )

    goal_info = state["structured_data"].get("goal", {})
    goal_context = SystemMessage(
        content=fill_prompt_template(
            MILESTONE_FORMULATOR_CONTEXT,
            dict(goal_info=goal_info),
        )
    )

    context_till_now = state.get("current_context", [])
    user_messages = [state["last_user_message"]] if state["last_user_message"] else []

    # Persist the new user message into context
    state["current_context"].extend(user_messages)

    full_context = [system_message, goal_context] + context_till_now + user_messages
    return full_context, state


def update_state_on_response(state: PlanState, response: BaseMessage):
    try:
        response_json = extract_json(response.content)
    except Exception as e:
        logger.error(f"JSON extraction failed in Milestone Formulator: {e}")
        response_json = {}

    intent = response_json.get("intent")
    is_complete = response_json.get("is_complete", False)
    milestone_details = response_json.get("milestones")
    to_user = response_json.get("to_user")

    state["current_context"].append(response)

    if to_user:
        state["to_user"].append(
            AgentMessage(agent=agent_utils.MILESTONE_FORMULATOR, message=to_user)
        )

    if intent:
        state["stage"] = get_next_agent_using_intent(intent)

    if is_complete and milestone_details:
        m_objs, t_objs = commit_milestones(milestone_details, state)
        state["structured_data"]["milestones"] = m_objs
        state["structured_data"]["trackers"] = t_objs
        state["stage"] = agent_utils.ORCHESTRATOR
        state["current_context"] = []  # Clear context for the next phase
        logger.info("Milestones finalized. Returning control to Orchestrator.")

    return state


def run_milestone_formulator(state: PlanState):
    logger.info(f"--- Node: Milestone Formulator | User: {state.get('user_id')} ---")

    context, updated_state = get_full_context(state)
    # logger.info(
    #     f"Context prepared for LLM: {"\n\n".join([msg.content for msg in context])}"
    # )
    response = low_reasoning_gpt5mini(context)

    if response == None:
        return state

    new_state = update_state_on_response(updated_state, response)
    logger.info(f"Transitioning to stage: {new_state.get('stage')}")
    return new_state
